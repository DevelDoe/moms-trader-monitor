<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <!-- <link rel="stylesheet" href="../styles.css" /> -->
        <link rel="stylesheet" href="../flat.css" />

        <title>Notice Board</title>
        <style>
            /* Container styling */
            body {
                padding: 10px;
                margin: 0;
                color: #f0f0f0; /* light text for contrast */
                font-family: sans-serif; /* use app's font if needed */
                height: 100px;
                width: 100%;
                overflow-x: hidden;
                min-height: 63px;
            }
            .bonus-list,
            .news-list {
                position: relative;
                width: 100%;
                height: 100%;
                overflow: hidden;
                font-size: 16px;
                color: #f0f0f0;
                padding: 5px;
                margin: 0 auto;
                text-overflow: ellipsis;
                padding-left: 0px;
            }

            h2 {
                font-size: 16px !important;
            }

            .bonus-item {
                position: absolute;
                display: flex;
                align-items: center;
                white-space: nowrap;
                opacity: 0;
                pointer-events: none;
                height: 30px;
            }

            .bonus-item.show {
                animation: slideIn 10s linear forwards;
                opacity: 1;
                white-space: nowrap;
                text-overflow: ellipsis;
            }

            .news-item {
                font-weight: bold;
                cursor: pointer;
                white-space: nowrap;
                text-overflow: ellipsis;
            }

            .news-item.show {
                opacity: 1;
            }

            .bonus-item {
                pointer-events: none;
            }
            .news-item {
                pointer-events: auto;
            }

            @keyframes slide-in {
                0% {
                    transform: translateX(200%);
                    opacity: 0;
                }
                100% {
                    transform: translateX(0%);
                    opacity: 1;
                }
            }

            @keyframes slide-out {
                0% {
                    transform: translateX(0%);
                    opacity: 1;
                }
                100% {
                    transform: translateX(-100%);
                    opacity: 0;
                }
            }

            @keyframes slideIn {
                0% {
                    transform: translateX(300%);
                    opacity: 0;
                }
                10% {
                    transform: translateX(0%);
                    opacity: 1;
                }
                90% {
                    transform: translateX(0%);
                    opacity: 1;
                }
                100% {
                    transform: translateX(-100%);
                    opacity: 0;
                }
            }

            .slide-in {
                animation: slide-in 0.6s ease-out forwards;
            }

            .slide-out {
                animation: slide-out 0.6s ease-in forwards;
            }

            .icon {
                font-size: 20px;
                margin-right: 8px;
            }
            .bullish-news {
                color: #1bcf65;
                /* border-left: 4px solid #1bcf65; */
            }

            .bearish-news {
                color: #e70049;
                /* border-left: 4px solid #e70049; */
            }

            .neutral-news {
                color: #f0f0f0;
                /* border-left: 4px solid #666; */
            }
            .bonus-item,
            .news-item {
                display: flex;
                flex-direction: row;
                align-items: center;
            }

            .bonus-item .icon,
            .news-item .icon {
                flex: 0 0 30px; /* fixed width for icon column */
                display: flex;
                justify-content: center;
                align-items: center;
                font-size: 18px;
                margin-right: 6px;
            }

            .bonus-item .desc,
            .news-item .desc {
                /* flex: 1; */
                /* overflow: hidden; */
                text-overflow: ellipsis;
                /* white-space: nowrap; */
            }
            @keyframes scrollVertical {
                0% {
                    transform: translateY(0%);
                }
                100% {
                    transform: translateY(-100%);
                }
            }

            .news-item .desc.scroll-vertical {
                display: inline-block;
                animation: scrollVertical 6s linear infinite;
                line-height: 1.2em;
            }
            .news-item .desc {
                max-height: 2.4em; /* shows 2 lines max by default */
                overflow: hidden;
                position: relative;
            }

            .news-item .desc .scroll-inner {
                display: inline-block;
            }
            h2 {
                padding: 0;
                padding-top: 3px;
                margin: 0 auto;
                margin-left: 10px;
                /* margin-top: 5px; */
            }
            /* symbol badges */
            .symbols {
                display: inline-flex;
                gap: 6px;
                margin-right: 8px;
                vertical-align: middle;
            }
            .badge {
                font-size: 12px;
                font-weight: 700;
                line-height: 1;
                padding: 4px 6px;
                padding-right: 10px;
                border-radius: 1px;
                color: #ffffff; /* dark text on light-ish bg */
            }

            /* 12 hue buckets (0..330 step 30): background + border color */
            .badge-h0 {
                background: hsla(0, 80%, 45%, 0.8);
            }
            .badge-h30 {
                background: hsla(30, 80%, 45%, 0.8);
            }
            .badge-h60 {
                background: hsla(60, 80%, 45%, 0.8);
            }
            .badge-h90 {
                background: hsla(90, 80%, 45%, 0.8);
            }
            .badge-h120 {
                background: hsla(120, 80%, 45%, 0.8);
            }
            .badge-h150 {
                background: hsla(150, 80%, 45%, 0.5);
            }
            .badge-h180 {
                background: hsla(180, 80%, 45%, 0.5);
            }
            .badge-h210 {
                background: hsla(210, 80%, 45%, 0.5);
            }
            .badge-h240 {
                background: hsla(240, 80%, 45%, 0.5);
            }
            .badge-h270 {
                background: hsla(270, 80%, 45%, 0.5);
            }
            .badge-h300 {
                background: hsla(300, 80%, 45%, 0.5);
            }
            .badge-h330 {
                background: hsla(330, 80%, 45%, 0.5);
            }
        </style>
    </head>
    <body class="draggable">

        <ul class="bonus-list no-drag"></ul>

        <script>
            const newsQueue = [];
            let isNewsDisplaying = false;
            const displayedNewsKeys = new Set();
            let blockList = [];
            let bullishList = [];
            let bearishList = [];
            let lastJFlashTime = 0;

            document.addEventListener("DOMContentLoaded", async () => {
                console.log("‚ö° Page Loaded. Initializing...");

                // Load settings and fetch initial news
                await loadSettings();
                await fetchNews(); // No need to fetch tickers anymore

                // Handle settings updates
                window.settingsAPI.onUpdate(async (updatedSettings) => {
                    console.log("üîÑ Settings changed. Updating UI...");
                    await loadSettings();
                });

                // Handle news updates
                window.newsAPI.onUpdate(() => {
                    console.log("üîÑ Received news update. Fetching fresh news...");
                    fetchNews(); // Refresh news on update
                });

                window.infobarAPI.onForceRefresh(() => {
                    console.log("üîÅ Refreshing infobar from main process trigger...");
                    displayedNewsKeys.clear(); // Allow re-showing previous news
                    fetchNews(); // Will re-queue everything again
                });
            });

            async function loadSettings() {
                try {
                    console.log("üì¢ Fetching settings...");
                    window.settings = await window.settingsAPI.get();

                    blockList = (window.settings.news?.blockList || []).map((w) => w.toLowerCase().trim());
                    bullishList = (window.settings.news?.bullishList || []).map((w) => w.toLowerCase().trim());
                    bearishList = (window.settings.news?.bearishList || []).map((w) => w.toLowerCase().trim());

                    console.log("‚úÖ Loaded settings:", window.settings);
                } catch (error) {
                    console.error("‚ö†Ô∏è Error loading settings:", error);
                    blockList = [];
                    bullishList = [];
                    bearishList = [];
                }
            }

            async function fetchNews() {
                try {
                    console.log("üì¢ Fetching news...");

                    const newsData = await window.newsAPI.get();
                    if (!Array.isArray(newsData)) {
                        console.error("‚ö†Ô∏è Expected an array but got:", newsData);
                        return;
                    }

                    const trackedTickers = (window.settings.news?.trackedTickers || []).map((s) => s.toUpperCase());

                    newsData.forEach((newsItem) => {
                        const sanitized = newsItem.headline.toLowerCase().trim();
                        const isBlocked = blockList.some((word) => sanitized.includes(word));
                        const isDuplicate = displayedNewsKeys.has(newsItem.id);
                        const isMultiSymbol = newsItem.symbols.length > 1;

                        // Skip blocked, duplicate, or multi-symbol
                        if (isBlocked || isDuplicate || isMultiSymbol) return;

                        // If showing only tracked tickers
                        if (window.settings.news?.showTrackedTickers) {
                            const symbol = newsItem.symbols?.[0]?.toUpperCase();
                            if (!symbol || !trackedTickers.includes(symbol)) return;
                        }

                        const type = getSentimentClass(newsItem.headline);
                        let truncated = newsItem.headline;
                        if (truncated.length > 240) truncated = truncated.slice(0, 239).trimEnd() + "‚Ä¶";

                        const syms = Array.isArray(newsItem.symbols) ? newsItem.symbols : [];
                        queueNewsItem(truncated, newsItem.id, type, syms);
                    });
                } catch (error) {
                    console.error("‚ùå Failed to fetch news:", error);
                }
            }

            // Determine sentiment (Bullish, Bearish, or Neutral)
            function getSentimentClass(headline) {
                const sanitizedHeadline = headline.toLowerCase().trim();
                const hasBullish = bullishList.some((word) => sanitizedHeadline.includes(word.toLowerCase()));
                const hasBearish = bearishList.some((word) => sanitizedHeadline.includes(word.toLowerCase()));

                if (hasBullish && !hasBearish) return "bullish";
                if (hasBearish && !hasBullish) return "bearish";
                if (hasBearish && hasBullish) return "neutral";
                return "neutral"; // Default to neutral if neither
            }

            /**
             * Initializes a scrolling ticker with the given items.
             * @param {string} containerSelector - CSS selector of the UL element.
             * @param {Array<{ icon: string, desc: string }>} dataList - List of items to display.
             * @param {number} interval - Time in ms between items. Default: 10000 (10s)
             */
            function initTicker(containerSelector, dataList, interval = 10000) {
                const container = document.querySelector(containerSelector);
                if (!container || !dataList || dataList.length === 0) return;

                // Clear existing items
                container.innerHTML = "";

                // Populate with new items
                dataList.forEach(({ icon, desc }) => {
                    const li = document.createElement("li");
                    li.className = "bonus-item draggable";
                    li.innerHTML = `<span class="icon">${icon}</span><span class="desc">${desc}</span>`;
                    container.appendChild(li);
                });

                const items = container.querySelectorAll(".bonus-item");
                let currentIndex = 0;

                const showItem = () => {
                    items.forEach((item, index) => {
                        item.classList.remove("show", "slide");
                        if (index === currentIndex) {
                            item.classList.add("show", "slide");
                        }
                    });
                };

                showItem(); // Show first

                setInterval(() => {
                    currentIndex = (currentIndex + 1) % items.length;
                    showItem();
                }, interval);
            }

            function showNewsItem(containerSelector, icon, desc, onDismiss, type = "neutral", symbols = []) {
                isNewsDisplaying = true;
                const container = document.querySelector(containerSelector);
                if (!container) return;

                container.innerHTML = "";
                playFlash();

                const li = document.createElement("li");
                li.className = `news-item show slide-in no-drag ${type}-news`;

                // left icon
                const iconSpan = document.createElement("span");
                iconSpan.className = "icon";
                iconSpan.textContent = icon;
                li.appendChild(iconSpan);

                // symbols badges
                if (Array.isArray(symbols) && symbols.length) {
                    const symWrap = document.createElement("span");
                    symWrap.className = "symbols";
                    for (const s of symbols) {
                        const sym = String(s).toUpperCase();
                        if (!sym) continue;
                        const badge = document.createElement("span");
                        badge.className = `badge ${hueClass(assignHue(sym))}`;
                        badge.textContent = sym;
                        symWrap.appendChild(badge);
                    }
                    li.appendChild(symWrap);
                }

                // headline text
                const descSpan = document.createElement("span");
                descSpan.className = "desc";
                descSpan.innerHTML = `<span class="scroll-inner">${desc}</span>`;
                li.appendChild(descSpan);

                // mount and scrolling logic
                container.appendChild(li);
                setTimeout(() => {
                    const inner = descSpan.querySelector(".scroll-inner");
                    if (inner && descSpan.clientHeight < inner.scrollHeight) inner.classList.add("scroll-vertical");
                }, 50);

                const cleanup = () => {
                    container.innerHTML = "";
                    isNewsDisplaying = false;
                    if (typeof onDismiss === "function") onDismiss();
                    processNextNews();
                };
                li.addEventListener("click", () => {
                    li.classList.remove("slide-in");
                    li.classList.add("slide-out");
                    li.addEventListener("animationend", cleanup, { once: true });
                });
                setTimeout(() => li.click(), 30000);
            }

            function queueNewsItem(desc, id = null, type = "neutral", symbols = []) {
                if (id && displayedNewsKeys.has(id)) return;

                const icon = type === "bullish" ? "üò∫" : type === "bearish" ? "üôÄ" : "üòº";
                newsQueue.push({ icon, desc, type, symbols });
                if (id) displayedNewsKeys.add(id);
                if (!isNewsDisplaying) processNextNews();
            }

            function processNextNews() {
                if (newsQueue.length > 0) {
                    const { icon, desc, type, symbols } = newsQueue.shift();
                    showNewsItem(
                        ".bonus-list",
                        icon,
                        desc,
                        () => {
                            if (newsQueue.length === 0) initTicker(".bonus-list", bonusItems);
                        },
                        type,
                        symbols
                    );
                }
            }

            function playFlash() {
                const now = Date.now();
                const gap = 3000;
                if (now - lastJFlashTime < gap) {
                    console.log("Jingle call debounced.");
                    return;
                }
                lastJFlashTime = now;

                // Create a new Audio object and set the source to your custom sound file
                const audio = new Audio("./flash.mp3");

                audio.volume = 0.6;

                audio
                    .play()
                    .then(() => {
                        console.log("Sound played successfully.");
                    })
                    .catch((error) => {
                        console.error("Error playing sound:", error);
                    });
            }

            const bonusItems = [
                { icon: "‚ùÑÔ∏è", desc: "Tiny Volume" },
                { icon: "üí§", desc: "Low Volume" },
                { icon: "üöõ", desc: "Medium Volume" },
                { icon: "üî•", desc: "High Volume" },
                { icon: "üöÄ", desc: "Parabolic Volume" },
                { icon: "1Ô∏è‚É£", desc: "Float around 1M" },
                { icon: "5Ô∏è‚É£", desc: "Float around 5M" },
                { icon: "üîü", desc: "Float around 10M" },
                { icon: "50", desc: "Float around 50M" },
                { icon: "100", desc: "Float around 100M" },
                // { icon: "200", desc: "Float around 200M" },
                // { icon: "500", desc: "Float around 500M" },
                // { icon: "600+", desc: "Float higher than 600M" },
                { icon: "‚ö†Ô∏è", desc: "Float is corrupted" },
                { icon: "üèõÔ∏è", desc: "High insider/institutional/locked shares holders" },
                { icon: "üòº", desc: "Catalyst in play ‚Äî recent news may affect momentum" },
                { icon: "üò∫", desc: "Bullish news - may affect momentum" },
                { icon: "üôÄ", desc: "Bearish news - may affect momentum" },
                { icon: "üìà", desc: "New high" },
                { icon: "üîÅ", desc: "Recovering ‚Äî stock is bouncing back after a downtrend" },
                { icon: "üß¨", desc: "Biotechnology stock" },
                { icon: "üåø", desc: "Cannabis stock" },
                { icon: "üåå", desc: "Space industry stock" },
                { icon: "üá®üá≥", desc: "China/Hong Kong-based company" },
                { icon: "ü©≥", desc: "High short interest (more than 20% of float)" },
                { icon: "ü•Ö", desc: "Company is currently running at a net loss" },
                { icon: "üìÇ", desc: "Registered S-3 filing" },
                { icon: "üö®", desc: "High dilution risk: Net loss + Registered S-3" },
            ];

            function assignHue(symbol) {
                if (!symbol) return 210;
                const key = String(symbol).trim().toUpperCase();
                let sum = 0;
                for (let i = 0; i < key.length; i++) sum += key.charCodeAt(i);
                return (sum * 37) % 360;
            }
            function hueClass(h) {
                const n = ((Number(h) % 360) + 360) % 360;
                const bucket = (Math.round(n / 30) * 30) % 360; // 0,30,...330
                return `badge-h${bucket}`;
            }

            // Show regular ticker
            initTicker(".bonus-list", bonusItems);
        </script>
    </body>
</html>
