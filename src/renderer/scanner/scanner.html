<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>MTP Alerts</title>
        <link rel="stylesheet" href="../styles.css" />
        <style>
            body {
                background-color: #1c1d23;
                color: #e0e0e0;
                font-size: 10px;
                position: relative;
                padding: 0px 10px;
                margin: 0 auto;
            }
            #log {
                overflow-y: auto;
                padding: 5px;
                border-radius: 5px;
                list-style-type: none;
                width: 200px;
                font-size: 14px;
                position: fixed;
                bottom: 130px;
            }
            .symbol-data {
                font-size: 12px;
            }
            #log li {
                float: left;
            }
            .alert {
                padding: 5px;
                margin: 5px 0;
                border-radius: 5px;
                font-weight: bold;
                display: flex;
                justify-content: space-between;
                align-items: center;
                opacity: 0;
                animation: fadeIn 0.3s forwards;
            }
            .alert-symbol {
                margin-right: 3px;
                font-size: 10px;
            }
            .up {
                color: #28a745;
                border-left: 5px solid #28a745;
            }
            .down {
                color: #dc3545;
                border-left: 5px solid #dc3545;
            }
            @keyframes fadeIn {
                from {
                    opacity: 0;
                }
                to {
                    opacity: 1;
                }
            }
            /* Symbol Summary */
            #symbol-summary {
                font-size: 14px;
                background-color: #1c1d23;
                position: fixed;
                bottom: 0;
            }
            ul {
                padding: 0;
            }
            .symbol-item {
                padding: 3px;
                list-style-type: none;
                font-weight: bold;
                margin-bottom: 2px;
            }
            /* Progress bar styling */
            .progress-bar {
                display: inline-block;
                margin: 0 5px;
            }
            .segment {
                display: inline-block;
                width: 8px;
                height: 10px;
                background-color: #555;
                margin-right: 1px;
            }
            .segment {
    display: inline-block;
    width: 8px;
    height: 10px;
    background-color: #555; /* Neutral */
    margin-right: 1px;
}

.segment.filled.up {
    background-color: #28a745; /* Green for positive change */
}

.segment.filled.down {
    background-color: #dc3545; /* Red for negative change */
}

        </style>
    </head>
    <body class="draggable">
        <ul id="log"></ul>
        <div id="symbol-summary">
            <ul id="symbol-list"></ul>
        </div>

        <script>
            const logElement = document.getElementById("log");
            const symbolListElement = document.getElementById("symbol-list");
            const maxAlerts = 12;

            // Track the latest percentage for each symbol.
            const symbolPercents = {};
            const symbolColors = {}; // For fixed background colors

            // Generate a distinct color for each symbol.
            function getSymbolColor(symbol) {
                if (!symbolColors[symbol]) {
                    const hash = [...symbol].reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const hue = (hash * 37) % 360;
                    const saturation = 80;
                    const lightness = 50;
                    const alpha = 0.5;
                    symbolColors[symbol] = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                }
                return symbolColors[symbol];
            }

            function play() {
                // Create a new AudioContext
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const startTime = audioCtx.currentTime;
                const beepDuration = 0.5; // duration of the beep in seconds

                // Create an oscillator and gain node
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                // Connect the oscillator to the gain node, then to the destination (speakers)
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                // Set the oscillator frequency and waveform type
                oscillator.frequency.value = 963;
                oscillator.type = "square";

                // Start and stop the oscillator to play the sound
                oscillator.start(startTime);
                oscillator.stop(startTime + beepDuration);

                // Apply a quick fade-out to smooth out the sound and avoid clicks
                gainNode.gain.setValueAtTime(1, startTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + beepDuration);
            }
           
            
            ws.onmessage = function (event) {
    console.log("[CLIENT] Received:", event.data);
    try {
        const alertData = JSON.parse(event.data);
        // Validate the incoming data.
        if (!alertData.symbol || !alertData.direction || alertData.change_percent === undefined || alertData.price === undefined || alertData.volume === undefined) {
            console.warn("[CLIENT] Received malformed alert:", alertData);
            return;
        }

        // Filter out alerts with price below $2.
        if (alertData.price < 1.75) {
            console.log(`[CLIENT] Alert with price $${alertData.price.toFixed(2)} filtered out.`);
            return;
        }

        const symbol = alertData.symbol;

        // Apply the negative sign if direction is "DOWN".
        const percent = alertData.direction === "DOWN" ? -alertData.change_percent : alertData.change_percent;

        // Update the symbol's latest percentage.
        symbolPercents[symbol] = percent;

        // Create the alert element.
        const alertDiv = document.createElement("li");
        alertDiv.className = `alert ${alertData.direction.toLowerCase()}`;

        // Create the symbol element with its background color.
        const coloredSymbol = `<span class="alert-symbol" style="background-color: ${getSymbolColor(symbol)}; 
              padding: 2px 5px; border-radius: 3px; color: #1c1d23;">${symbol}</span>`;

        alertDiv.innerHTML = `${coloredSymbol}<span class="symbol-data">
              <span>${percent.toFixed(2)}%</span> $${alertData.price.toFixed(2)}
              V${alertData.volume}</span>`;

        // Append the new alert.
        logElement.appendChild(alertDiv);

        // Remove oldest alerts if exceeding maxAlerts.
        while (logElement.children.length > maxAlerts) {
            logElement.removeChild(logElement.firstChild);
        }

        // Update the symbol summary.
        updateSymbolSummary();
    } catch (error) {
        console.error("[CLIENT] Error parsing message:", error);
    }
};


            // Function to create and manage the WebSocket connection.
            function connect() {
                const ws = new WebSocket("ws://192.168.1.17:8000/ws");

                ws.onopen = function () {
                    console.log("[CLIENT] Connected to WebSocket server");
                    ws.send(JSON.stringify({ client_id: "web-client" }));
                };

                ws.onmessage = function (event) {
                    console.log("[CLIENT] Received:", event.data);
                    try {
                        const alertData = JSON.parse(event.data);
                        // Validate the incoming data.
                        if (!alertData.symbol || !alertData.direction || alertData.change_percent === undefined || alertData.price === undefined || alertData.volume === undefined) {
                            console.warn("[CLIENT] Received malformed alert:", alertData);
                            return;
                        }

                        // Filter out alerts with price below $2.
                        if (alertData.price < 1.75) {
                            console.log(`[CLIENT] Alert with price $${alertData.price.toFixed(2)} filtered out.`);
                            return;
                        }

                        const symbol = alertData.symbol;
                        // Update the symbol's latest percentage.
                        symbolPercents[symbol] = alertData.change_percent;

                        // Create the alert element.
                        const alertDiv = document.createElement("li");
                        alertDiv.className = `alert ${alertData.direction.toLowerCase()}`;

                        // Create the symbol element with its background color.
                        const coloredSymbol = `<span class="alert-symbol" style="background-color: ${getSymbolColor(symbol)}; 
              padding: 2px 5px; border-radius: 3px; color: #1c1d23;">${symbol}</span>`;

                        alertDiv.innerHTML = `${coloredSymbol}<span class="symbol-data">
              <span>${alertData.change_percent.toFixed(2)}%</span> $${alertData.price.toFixed(2)}
              V${alertData.volume}</span>`;

                        // Append the new alert.
                        logElement.appendChild(alertDiv);

                        // Remove oldest alerts if exceeding maxAlerts.
                        while (logElement.children.length > maxAlerts) {
                            logElement.removeChild(logElement.firstChild);
                        }

                        // Update the symbol summary.
                        updateSymbolSummary();
                    } catch (error) {
                        console.error("[CLIENT] Error parsing message:", error);
                    }
                };

                ws.onerror = function (error) {
                    console.error("[CLIENT] WebSocket error:", error);
                };

                ws.onclose = function () {
                    console.log("[CLIENT] Disconnected from WebSocket server. Retrying in 5 seconds...");
                    setTimeout(connect, 5000); // Retry after 5 seconds.
                };
            }

            // Establish the initial connection.
            connect();
        </script>
    </body>
</html>
